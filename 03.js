// Задача 3:
// Реализовать аналог библиотеки Math (можно назвать MathX) с базовым набором функций, используя замыкания:
// вычисление N-го числа в ряду Фибоначчи
// вычисление всех чисел в ряду Фибоначчи до числа N
// вычисление N-го просто числа
// вычисление всех простых чисел до числа N

// Решение:

const MathX = (function () {
  //  Функция для вычисления всех чисел в ряду Фибоначчи до числа N
  const calculateFibbonachiRow = (num) => {
    // Ряд Фибоначчи - последовательность чисел, в которой первые два числа равны 1 и 1
    // Запишем их как первые два элемента массива и считать будем от них
    let f = [1, 1];
    // Начинаем цикл с i = 2, так как данный индекс будет следующим для добавления в наш массив
    // Пока счетчик меньше переданного в функцию числа
    for (let i = 2; i <= num; i++) {
      // Каждое последующее число в последовательности равно сумме двух предыдущих чисел
      // Поэтому чтобы найти все числа до числа N необходимо находить 2 предыдущих его числа
      f[i] = f[i - 1] + f[i - 2];
    }
    // Получаем массив чисел до N
    return f;
  };
  // Функция для вычисления всех простых чисел до числа N
  const calculatePrimeNumbers = (num) => {
    // Так как по переданному числу нельзя точно сказать каким будет простое число - будем искать простые числа до 1 млн.
    // В данном случае, программа будет работать достаточно оптимально
    const maxSize = 1000000;
    // Создадим массив primes для хранения найденных простых чисел
    let primes = [];
    // Создадим массив, в котором по ходу работы программы будем "помечать" не простые числа как false.
    // По умолчанию все элементы массива будут true
    const numbers = Array(maxSize).fill(true);
    // Запускаем цикл, начиная с 2, так как 0 и 1 не являются простыми числами
    for (let p = 2; p < maxSize; p++) {
      // Если во время перебора чисел встречается простое число
      if (numbers[p] == true) {
        // Добавляем найденное простое число в массив простых чисел
        primes.push(p);
        // В случае, если переданное число равно количеству найденных - возвращаем массив простых чисел до num
        if (primes.length - 1 === num) {
          return primes;
        }
        // Начинаем обходить циклом все числа кратные p, начиная с p^2, так как все числа меньше p^2 уже были помечены на пред. шагах
        for (let i = p * p; i < maxSize; i += p) {
          // Помечаем в массиве numbers все числа кратные текущему числу р как false (не простые)
          numbers[i] = false;
        }
        // В случае, если функция обошла maxSize в 1 млн и не нашла простое число и переданным порядковым номером - прекращаем работу
        // И сообщаем об этом пользователю
      }
    }
    return "Number is too big";
  };

  return {
    // 1. Функция, которая возвращает N-ое число ряда Фибоначчи
    fibonachiNum: (num) => {
      // С помощью функции calculateFibbonachiRow мы находим N чисел ряда Фибоначчи
      // И возвращаем последнее (N-ое)
      return calculateFibbonachiRow(num).pop();
    },

    // 2. Функция, которая возвращает первые N чисел в ряду Фибоначчи
    fibonachiRow: (num) => {
      return calculateFibbonachiRow(num);
    },

    // 3. Функция, которая возвращает N-ое простое число
    primeNum: (num) => {
      return calculatePrimeNumbers(num).pop();
    },

    // 4. Функция, которая возвращает первые N простых чисел
    primeRow: (num) => {
      return calculatePrimeNumbers(num);
    },
  };
})();

// Проверка:
// Как известно, в программировании счёт всегда начинается с нуля, а не с единицы
// При выводе в консоль, также необходимо учитывать данный момент
console.log(MathX.fibonachiNum(10)); // 89
console.log(MathX.fibonachiRow(11)); // [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
console.log(MathX.primeNum(5)); // 13
console.log(MathX.primeRow(6)); // [2, 3, 5, 7, 11, 13, 17]
